# Two Pointers

## О подходе двух указателей для решения алгоритмов

### Содержание

- [Вариант A](#вариант-a)
- [Вариант B](#вариант-b)
- [Вариант C](#вариант-c)

---

## Вариант A
В рамках одной структуры данных (коллекции) ставятся два указателя: на начало и конец, и данные указатели двигаются друг к другу.

### 344. Reverse String
**Алгоритм:**
1. Устанавливаем указатели слева и справа: `left = 0`, `right = len(s)-1`.
2. Пока `left < right`:
   - Меняем местами символы.
   - Сдвигаем указатели: `left++`, `right--`.
3. Готово! Строка перевернута.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

### 125. Valid Palindrome
**Алгоритм:**
1. Устанавливаем два указателя: `left = 0`, `right = len(s)-1`.
2. Пока `left < right`:
   - Пропускаем не буквенные символы.
   - Сравниваем символы в нижнем регистре.
   - Если не совпадают → `return false`.
   - Иначе сдвигаем указатели.
3. `return true`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

### 1. Two Sum
**Алгоритм:**
1. Создаем хеш-таблицу.
2. Проходим по массиву:
   - Вычисляем `rem = target - v`.
   - Если `rem` уже в хеш-таблице → возвращаем индексы.
   - Иначе добавляем `v` в таблицу.
3. `return []`.

**Сложность:**
- Время: `O(n)`
- Память: `O(n)`

---

### 167. Two Sum II
**Алгоритм:**
1. Устанавливаем два указателя: `left = 0`, `right = len(s)-1`.
2. Пока `left < right`:
   - Вычисляем `curr = numbers[left] + numbers[right]`.
   - Если `curr == target` → возвращаем индексы.
   - Если `curr > target` → `right--`.
   - Если `curr < target` → `left++`.
3. `return []`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

### 15. 3Sum
**Алгоритм:**
1. Сортируем массив `O(n log n)`.
2. Перебираем элементы, избегая дубликатов.
3. Используем `Two Sum` с двумя указателями.
4. `return res`.

**Сложность:**
- Время: `O(n^2)`
- Память: `O(1)`

---

### 977. Squares of a Sorted Array
**Алгоритм:**
1. Устанавливаем два указателя в начале и конце.
2. Записываем квадраты больших значений справа налево.
3. `return res`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

### 11. Container With Most Water
**Алгоритм:**
1. Устанавливаем два указателя.
2. Пока `left < right`:
   - Вычисляем площадь.
   - Двигаем указатель с меньшей высотой.
3. `return maxS`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

## Вариант B
Два указателя находятся рядом и двигаются по определенной логике.

### 26. Remove Duplicates from Sorted Array
**Алгоритм:**
1. Если `nums` пуст, `return 0`.
2. Два указателя: `curr = 0`, `i = 1`.
3. Пока `i < len(nums)`, если `nums[curr] != nums[i]`:
   - `curr++`.
   - `nums[curr] = nums[i]`.
4. `return curr + 1`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

## Вариант C
Два указателя находятся в разных структурах данных.

### Is Subsequence
**Алгоритм:**
1. Устанавливаем указатели на начало `s` и `t`.
2. Пока `i < len(s)`, ищем `s[i]` в `t`.
3. `return i == len(s)`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

---

### 844. Backspace String Compare
**Алгоритм:**
1. Устанавливаем указатели на конец `s` и `t`.
2. Удаляем `#` и его эффект.
3. Сравниваем оставшиеся символы.
4. `return true`, если строки равны.

**Сложность:**
- Время: `O(n+m)`
- Память: `O(1)`

---

### 88. Merge Sorted Array
**Алгоритм:**
1. Устанавливаем три указателя: `p1 = n-1`, `p2 = m-1`, `i = n+m-1`.
2. Пока `p2 >= 0`:
   - Если `p1 >= 0` и `nums1[p1] > nums2[p2]`, записываем `nums1[i] = nums1[p1]`.
   - Иначе записываем `nums1[i] = nums2[p2]`.
   - Двигаем `i--`.
3. `return nums1`.

**Сложность:**
- Время: `O(n+m)`
- Память: `O(1)`

---
