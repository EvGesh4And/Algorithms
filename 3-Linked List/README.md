# Linked List

Связный список

**head** [ 2 | * ] → [ 5 | * ] → [ 3 | * ] → [ 8 | nil ]  **tail**  

#### Определение структуры узла:

```go
type Node struct {
   value int
   next  *Node
}
Каркас: 
```go

```

### 707. Design Linked List

# Алгоритм работы с односвязным списком

## Описание

1. Инициализируем структуру `MyLinkedList` с полем `head`, которое указывает на первый элемент списка.
2. Для получения значения элемента по индексу:
   - Проверяем, что индекс валиден и список не пуст.
   - Перебираем элементы, начиная с головы, пока не достигнем нужного индекса или конца списка.
   - Если индекс найден, возвращаем значение соответствующего узла, иначе возвращаем `-1`.
3. Для добавления элемента в начало списка:
   - Создаём новый узел с данным значением и связываем его с текущей головой списка.
   - Новый узел становится головой списка.
4. Для добавления элемента в конец списка:
   - Если список пуст, создаём новый узел и присваиваем его голове.
   - Если список не пуст, проходим по всем узлам до конца и добавляем новый узел в конец.
5. Для добавления элемента в список по индексу:
   - Если индекс больше нуля и список пуст, возвращаемся.
   - Если индекс равен нулю, добавляем элемент в начало.
   - Иначе, ищем узел на позиции `index-1` и вставляем новый узел между ним и следующим узлом.
6. Для удаления элемента по индексу:
   - Если индекс отрицателен или список пуст, ничего не делаем.
   - Если индекс равен нулю, сдвигаем голову на следующий узел.
   - Для других индексов, проходим до нужного узла и связываем его с узлом, который идет после удаляемого.

## Сложность

- Время:
  - Операции добавления в начало или конец: `O(n)` (для конца), `O(1)` (для начала).
  - Операции по индексу или удалению: `O(n)`.
- Память: `O(n)` (для хранения элементов списка).


### 876. Middle of the Linked List

**Алгоритм:**  
1. Проверяем, является ли голова списка пустой (nil). Если да, возвращаем nil.  
2. Инициализируем два указателя: `slow` и `fast`, оба указывают на голову списка.  
3. Перебираем список, двигая быстрый указатель на два шага за один раз, а медленный на один шаг.  
4. Когда быстрый указатель достигнет конца списка, медленный указатель будет указывать на середину.  
5. Возвращаем медленный указатель.

**Сложность:**  
- Время: O(n) — один проход по списку с двумя указателями.  
- Память: O(1) — используем только два дополнительных указателя.

### 2095. Delete the Middle Node of a Linked List

### Алгоритм: Удаление среднего элемента из списка

1. Проверяем, является ли голова списка пустой (nil). Если да, возвращаем nil.
2. Инициализируем два указателя: `slow` и `fast`, оба указывают на голову списка.
3. Перебираем список, двигая быстрый указатель на два шага за один раз, а медленный на один шаг.
4. Когда быстрый указатель достигнет конца списка, медленный указатель будет указывать на середину.
5. Удаляем элемент, на который указывает медленный указатель, сдвигая указатель на следующий элемент.
6. Возвращаем голову списка.

### Сложность:

- **Время:** O(n) — один проход по списку с двумя указателями.
- **Память:** O(1) — используем только два дополнительных указателя.

### 206. Reverse Linked List

### Алгоритм: Реверсировка связанного списка

1. Инициализируем два указателя: `past` и `current`. Указатель `current` указывает на голову списка, а `past` — на nil.
2. Проходим по списку, инвертируя указатели элементов. Для каждого элемента:
   - Сохраняем следующий элемент `current.Next` в `current`.
   - Перенаправляем указатель текущего элемента на предыдущий (то есть на `past`).
   - Передвигаем указатель `past` на текущий элемент и `current` на следующий.
3. Когда список обработан, `past` будет указывать на новый первый элемент, который теперь является головой списка.
4. Возвращаем голову нового списка.

### Сложность:

- **Время:** O(n) — один проход по списку.
- **Память:** O(1) — используем только два дополнительных указателя.

### 234. Palindrome Linked List  

### Алгоритм: Проверка на палиндром  

1. **Нахождение середины списка:**  
   - Используем два указателя: `slow` (двигается на 1 шаг) и `fast` (двигается на 2 шага).  
   - Когда `fast` достигает конца, `slow` оказывается в середине списка.  

2. **Реверс второй половины списка:**  
   - Проходим от середины до конца, инвертируя указатели `Next`.  
   - Получаем развернутую вторую половину списка.  

3. **Сравнение двух половин:**  
   - Используем два указателя: один начинает с головы списка, второй — с головы развернутой половины.  
   - Поэлементно сравниваем значения узлов.  
   - Если хотя бы одно значение не совпадает, возвращаем `false`.  

4. **Возвращаем `true`, если список является палиндромом.**  

### Сложность:  
- **Время:** O(n) — три линейных прохода по списку (поиск середины, реверс, сравнение).  
- **Память:** O(1) — изменения происходят in-place без выделения дополнительной памяти.

### 234. Palindrome Linked List  

### Алгоритм: Проверка на палиндром  

1. **Нахождение середины списка:**  
   - Используем два указателя: `slow` (двигается на 1 шаг) и `fast` (двигается на 2 шага).  
   - Когда `fast` достигает конца, `slow` оказывается в середине списка.  

2. **Реверс второй половины списка:**  
   - Проходим от середины до конца, инвертируя указатели `Next`.  
   - Получаем развернутую вторую половину списка.  

3. **Сравнение двух половин:**  
   - Используем два указателя: один начинает с головы списка, второй — с головы развернутой половины.  
   - Поэлементно сравниваем значения узлов.  
   - Если хотя бы одно значение не совпадает, возвращаем `false`.  

4. **Возвращаем `true`, если список является палиндромом.**  

### Сложность:  
- **Время:** O(n) — три линейных прохода по списку (поиск середины, реверс, сравнение).  
- **Память:** O(1) — изменения происходят in-place без выделения дополнительной памяти.  

---  

### 83. Remove Duplicates from Sorted List  

### Алгоритм: Удаление дубликатов из отсортированного списка  

1. **Инициализация указателя**:  
   - `current` указывает на `head`.  

2. **Проход по списку**:  
   - Пока `current` и `current.Next` не равны `nil`:  
     - Если `current.Val == current.Next.Val`, пропускаем `current.Next`, переподключая ссылки.  
     - Иначе двигаем `current` вперед.  

3. **Возвращаем `head` как новый список без дубликатов.**  

### Сложность:  
- **Время:** O(n) — один проход по списку.  
- **Память:** O(1) — нет дополнительного использования памяти.

### 234. Palindrome Linked List  

### Алгоритм: Проверка на палиндром  

1. **Нахождение середины списка:**  
   - Используем два указателя: `slow` (двигается на 1 шаг) и `fast` (двигается на 2 шага).  
   - Когда `fast` достигает конца, `slow` оказывается в середине списка.  

2. **Реверс второй половины списка:**  
   - Проходим от середины до конца, инвертируя указатели `Next`.  
   - Получаем развернутую вторую половину списка.  

3. **Сравнение двух половин:**  
   - Используем два указателя: один начинает с головы списка, второй — с головы развернутой половины.  
   - Поэлементно сравниваем значения узлов.  
   - Если хотя бы одно значение не совпадает, возвращаем `false`.  

4. **Возвращаем `true`, если список является палиндромом.**  

### Сложность:  
- **Время:** O(n) — три линейных прохода по списку (поиск середины, реверс, сравнение).  
- **Память:** O(1) — изменения происходят in-place без выделения дополнительной памяти.  

---  

### 83. Remove Duplicates from Sorted List  

### Алгоритм: Удаление дубликатов из отсортированного списка  

1. **Инициализация указателя**:  
   - `current` указывает на `head`.  

2. **Проход по списку**:  
   - Пока `current` и `current.Next` не равны `nil`:  
     - Если `current.Val == current.Next.Val`, пропускаем `current.Next`, переподключая ссылки.  
     - Иначе двигаем `current` вперед.  

3. **Возвращаем `head` как новый список без дубликатов.**  


### Сложность:  
- **Время:** O(n) — один проход по списку.  
- **Память:** O(1) — нет дополнительного использования памяти.  


### 19. Remove Nth Node From End of List  

### Алгоритм: Удаление n-го узла с конца  

1. **Использование двух указателей**:  
   - Заводим два указателя `p1` и `p2`, оба начинаются с фиктивного узла перед `head`.  

2. **Сдвиг `p2` на `n` шагов вперед**:  
   - Таким образом, `p1` и `p2` окажутся на нужном расстоянии друг от друга.  

3. **Одновременное движение `p1` и `p2`**:  
   - Когда `p2` дойдет до конца, `p1` окажется перед удаляемым элементом.  
   - Меняем ссылки, удаляя нужный узел.  

4. **Возвращаем `head.Next` как новую голову списка.**  

### Сложность:  
- **Время:** O(n) — один проход по списку.  
- **Память:** O(1) — используем только два указателя.

### 24. Swap Nodes in Pairs  

### Алгоритм: Попарная смена узлов  

1. **Создание фиктивного узла**:  
   - Вводим `fakeHead`, который указывает на `head`, чтобы упростить обработку граничных случаев.  

2. **Проход по списку парами**:  
   - Используем указатель `current`, который всегда указывает на узел перед парой, которую мы хотим поменять.  
   - Определяем `first` (первый узел пары) и `second` (второй узел пары).  
   - Обновляем ссылки так, чтобы `second` стал перед `first`.  
   - Продвигаем `current` на две позиции вперед.  

3. **Возвращаем новый `head` списка.**  

### Сложность:  
- **Время:** O(n) — один проход по списку.  
- **Память:** O(1) — меняем ссылки без выделения дополнительной памяти.

### 24. Merge Two Sorted Lists  

### Алгоритм: Слияние двух отсортированных списков  

1. **Создание фиктивного узла**:  
   - Вводим `ficHead`, который служит фиктивным узлом, помогающим упростить логику объединения списков. Он указывает на начало нового объединенного списка.  

2. **Проход по обоим спискам**:  
   - Используем указатель `current`, который всегда указывает на последний узел нового списка.  
   - Проходим по обоим спискам одновременно, выбирая наименьший элемент из каждого и добавляем его в новый список.  
   - После добавления элемента из одного списка, двигаем указатель в этом списке на следующий узел.  

3. **Обработка оставшихся узлов**:  
   - Когда один из списков закончится, добавляем оставшиеся элементы другого списка в конец нового списка.  

4. **Возвращаем новый объединенный список**.  

### Сложность:  
- **Время:** O(n + m) — один проход по каждому из списков, где n и m — их длины.  
- **Память:** O(1) — изменяем ссылки без выделения дополнительной памяти.

### 141. Linked List Cycle  

### Алгоритм: Проверка на цикл в списке  

1. **Использование двух указателей**:  
   - Вводим два указателя: `slow` и `fast`, которые оба начинают с `head`. Указатель `slow` двигается на один шаг за раз, а `fast` — на два шага за раз.  
   - Если в списке есть цикл, то в какой-то момент указатели `slow` и `fast` встретятся на одном узле.

2. **Проход по списку**:  
   - В цикле проверяем, что указатель `fast` и его следующий элемент (`fast.Next`) не равны `nil`.  
   - Если на каком-то шаге указатели `slow` и `fast` указывают на один и тот же узел, значит, в списке есть цикл.

3. **Возвращаем результат**:  
   - Если цикл найден, возвращаем `true`, иначе — `false`.

### Сложность:  
- **Время:** O(n) — один проход по списку.  
- **Память:** O(1) — используем только два указателя, не выделяя дополнительной памяти.