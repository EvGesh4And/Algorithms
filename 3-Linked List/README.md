# Linked List

Связный список

**head** [ 2 | * ] → [ 5 | * ] → [ 3 | * ] → [ 8 | nil ]  **tail**  

#### Определение структуры узла:

```go
type Node struct {
   value int
   next  *Node
}
Каркас: 
```go

```

### 707. Design Linked List

# Алгоритм работы с односвязным списком

## Описание

1. Инициализируем структуру `MyLinkedList` с полем `head`, которое указывает на первый элемент списка.
2. Для получения значения элемента по индексу:
   - Проверяем, что индекс валиден и список не пуст.
   - Перебираем элементы, начиная с головы, пока не достигнем нужного индекса или конца списка.
   - Если индекс найден, возвращаем значение соответствующего узла, иначе возвращаем `-1`.
3. Для добавления элемента в начало списка:
   - Создаём новый узел с данным значением и связываем его с текущей головой списка.
   - Новый узел становится головой списка.
4. Для добавления элемента в конец списка:
   - Если список пуст, создаём новый узел и присваиваем его голове.
   - Если список не пуст, проходим по всем узлам до конца и добавляем новый узел в конец.
5. Для добавления элемента в список по индексу:
   - Если индекс больше нуля и список пуст, возвращаемся.
   - Если индекс равен нулю, добавляем элемент в начало.
   - Иначе, ищем узел на позиции `index-1` и вставляем новый узел между ним и следующим узлом.
6. Для удаления элемента по индексу:
   - Если индекс отрицателен или список пуст, ничего не делаем.
   - Если индекс равен нулю, сдвигаем голову на следующий узел.
   - Для других индексов, проходим до нужного узла и связываем его с узлом, который идет после удаляемого.

## Сложность

- Время:
  - Операции добавления в начало или конец: `O(n)` (для конца), `O(1)` (для начала).
  - Операции по индексу или удалению: `O(n)`.
- Память: `O(n)` (для хранения элементов списка).


### 876. Middle of the Linked List

**Алгоритм:**  
1. Проверяем, является ли голова списка пустой (nil). Если да, возвращаем nil.  
2. Инициализируем два указателя: `slow` и `fast`, оба указывают на голову списка.  
3. Перебираем список, двигая быстрый указатель на два шага за один раз, а медленный на один шаг.  
4. Когда быстрый указатель достигнет конца списка, медленный указатель будет указывать на середину.  
5. Возвращаем медленный указатель.

**Сложность:**  
- Время: O(n) — один проход по списку с двумя указателями.  
- Память: O(1) — используем только два дополнительных указателя.

### 2095. Delete the Middle Node of a Linked List

### Алгоритм: Удаление среднего элемента из списка

1. Проверяем, является ли голова списка пустой (nil). Если да, возвращаем nil.
2. Инициализируем два указателя: `slow` и `fast`, оба указывают на голову списка.
3. Перебираем список, двигая быстрый указатель на два шага за один раз, а медленный на один шаг.
4. Когда быстрый указатель достигнет конца списка, медленный указатель будет указывать на середину.
5. Удаляем элемент, на который указывает медленный указатель, сдвигая указатель на следующий элемент.
6. Возвращаем голову списка.

### Сложность:

- **Время:** O(n) — один проход по списку с двумя указателями.
- **Память:** O(1) — используем только два дополнительных указателя.

### 206. Reverse Linked List

### Алгоритм: Реверсировка связанного списка

1. Инициализируем два указателя: `left` и `current`. Указатель `current` указывает на голову списка, а `left` — на nil.
2. Проходим по списку, инвертируя указатели элементов. Для каждого элемента:
   - Сохраняем следующий элемент `current.Next` в `current`.
   - Перенаправляем указатель текущего элемента на предыдущий (то есть на `left`).
   - Передвигаем указатель `left` на текущий элемент и `current` на следующий.
3. Когда список обработан, `left` будет указывать на новый первый элемент, который теперь является головой списка.
4. Возвращаем голову нового списка.

### Сложность:

- **Время:** O(n) — один проход по списку.
- **Память:** O(1) — используем только два дополнительных указателя.