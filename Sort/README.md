# Сортировки

## Простые

### Сортировка пузырьком (Bubble Sort)

Идея алгоритма заключается в том, что **на каждой итерации сравниваются соседние элементы массива** и, если они находятся в неправильном порядке, то они меняются местами. Процесс повторяется до тех пор, пока не будет выполнено условие, что массив отсортирован.

Визуально это напоминает пузырьки, которые поднимаются на поверхность воды, поэтому алгоритм получил такое название.

Визуально алгоритм можно представить так:

```
[5, 3, 8, 4, 2]
[3, 5, 8, 4, 2]
[3, 5, 4, 8, 2]
[3, 5, 4, 2, 8]
[3, 4, 5, 2, 8]
[3, 4, 2, 5, 8]
[3, 2, 4, 5, 8]
[2, 3, 4, 5, 8] (отсортированный массив)
```

Алгоритм работает следующим образом:
1. Сравниваются первые два элемента массива.
2. Если первый элемент больше второго, то они меняются местами.
3. Переход к следующей паре элементов и повторение шагов 1-2.
4. Процесс повторяется до тех пор, пока не будет выполнено условие, что массив отсортирован (т.е. не осталось пар элементов, которые нужно менять местами).

Код на Go:

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        swapped := false
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }
        if !swapped {
            break
        }
    }
}
```

Эффективность алгоритма можно улучшить, добавив флаг, который будет указывать, были ли произведены какие-либо обмены на текущей итерации. Если обменов не было, то массив уже отсортирован и можно завершить выполнение алгоритма.

**Эффективен при использовании на небольших массивах или в случаях, когда массив уже почти отсортирован.**

Сложность алгоритма: `O(n^2)` в худшем и среднем случае, `O(n)` в лучшем случае (если массив уже отсортирован).

### Сортировка вставками (Insertion Sort)

Идея алгоритма заключается в том, что **массив делится на две части: отсортированную и неотсортированную**. На каждой итерации берется один элемент из неотсортированной части и вставляется в нужное место в отсортированной части.

Визуально это можно представить так:

```
[5, 3, 8, 4, 2] (5 уже отсортирован)
[5, 3, 8, 4, 2] (вставляем 3)
[3, 5, 8, 4, 2] (вставляем 5)
[3, 5, 8, 4, 2] (вставляем 3)
[3, 5, 8, 4, 2] (вставляем 8)
[3, 4, 5, 8, 2] (вставляем 4)
[2, 3, 4, 5, 8] (вставляем 2) (отсортированный массив)
```

Алгоритм работает следующим образом:
1. Сначала считается, что первый элемент уже отсортирован.
2. Берется следующий элемент из неотсортированной части.
3. Сравнивается этот элемент с элементами отсортированной части и вставляется в нужное место.
4. Процесс повторяется до тех пор, пока не будут обработаны все элементы массива.

Код на Go:

```go
func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {        
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}
```

**Эффективен при использовании на небольших массивах или в случаях, когда массив уже почти отсортирован.**

Сложность алгоритма: `O(n^2)` в худшем и среднем случае, `O(n)` в лучшем случае (если массив уже отсортирован).

### Сортировка выбором (Selection Sort)

Идея алгоритма заключается в том, что **на каждой итерации находится минимальный элемент из неотсортированной части массива и меняется местами с первым элементом неотсортированной части**. Процесс повторяется для оставшейся части массива.

Визуально это можно представить так:

```
[5, 3, 8, 4, 2]
[2, 3, 8, 4, 5] (находим минимальный элемент 2)
[2, 3, 8, 4, 5] (находим минимальный элемент 3)
[2, 3, 4, 8, 5] (находим минимальный элемент 4)
[2, 3, 4, 5, 8] (находим минимальный элемент 5) (отсортированный массив)
```

Алгоритм работает следующим образом:
1. Сначала считается, что весь массив неотсортирован.
2. На каждой итерации находится минимальный элемент из неотсортированной части массива.
3. Меняется местами этот минимальный элемент с первым элементом неотсортированной части.
4. Процесс повторяется для оставшейся части массива.

Код на Go:

```go
func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {        
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}
```

**Эффективен при использовании на небольших массивах или в случаях, когда массив уже почти отсортирован.**

Сложность алгоритма: `O(n^2)` в худшем и среднем случае, `O(n^2)` в лучшем случае (если массив уже отсортирован).

### Сортировка Шелла (Shell Sort)
Сортировка Шелла является улучшенной версией сортировки вставками. Идея заключается в том, что **массив делится на несколько подмассивов, которые сортируются независимо друг от друга**. Затем подмассивы сливаются в один отсортированный массив.

Визуально это можно представить так:

```
[5, 3, 8, 4, 2] (исходный массив)
[5, 3, 8] (первый подмассив)
[4, 2] (второй подмассив)
[3, 5, 8] (первый подмассив отсортирован)
[2, 4] (второй подмассив отсортирован)
[2, 3, 4, 5, 8] (объединенный отсортированный массив)
```

Алгоритм работает следующим образом:
1. Сначала выбирается шаг (gap), который определяет, на сколько элементов будут разделены подмассивы.
2. На каждой итерации берется один элемент из каждого подмассива и вставляется в нужное место в отсортированном массиве.
3. Шаг уменьшается, и процесс повторяется до тех пор, пока шаг не станет равным 1.
4. В конце выполняется обычная сортировка вставками для окончательной сортировки массива.

Код на Go:

```go
func shellSort(arr []int) {
    n := len(arr)
    gap := n / 2
    for gap > 0 {           
        for i := gap; i < n; i++ {
            temp := arr[i]
            j := i
            for j >= gap && arr[j-gap] > temp {
                arr[j] = arr[j-gap]
                j -= gap
            }
            arr[j] = temp
        }
        gap /= 2
    }
}
```

**Эффективен при использовании на небольших массивах или в случаях, когда массив уже почти отсортирован.**


Сложность алгоритма: `O(n^2)` в худшем и среднем случае, `O(n log n)` в лучшем случае (если массив уже отсортирован).


## Эффективные

### Быстрая сортировка (Quick Sort)

Быстрая сортировка — это один из самых эффективных алгоритмов сортировки, который использует метод "разделяй и властвуй". Идея заключается в том, что **массив делится на две части: элементы меньше опорного и элементы больше опорного**. Затем эти части сортируются рекурсивно.

```go
func quickSort(arr []int) {
	n := len(arr)
	if n < 2 {
		return
	}
	// Randomly select a pivot to avoid worst-case performance on sorted input
	rnd := rand.Intn(n)
	if rnd != n-1 {
		arr[rnd], arr[n-1] = arr[n-1], arr[rnd]
	}

	pivot := arr[n-1]
	idx := 0
	for i := 0; i < n-1; i++ {
		if arr[i] < pivot {
			arr[idx], arr[i] = arr[i], arr[idx]
			idx++
		}
	}
	arr[idx], arr[n-1] = arr[n-1], arr[idx]
	quickSort(arr[:idx])
	quickSort(arr[idx+1:])
}
```

**Эффективен при использовании на больших массивах.**

Сложность алгоритма: `O(n log n)` в среднем случае, `O(n^2)` в худшем случае (если массив уже отсортирован или содержит много одинаковых элементов).



### Сортировка слиянием (Merge Sort)

Сортировка слиянием — это еще один эффективный алгоритм сортировки, который также использует метод "разделяй и властвуй". Идея заключается в том, что **массив делится на две части, которые сортируются рекурсивно, а затем сливаются в один отсортированный массив**.

```go
func mergeSort(arr []int) []int {
    if len(arr) < 2 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}
func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

**Эффективен при использовании на больших массивах.**

Сложность алгоритма: `O(n log n)` в среднем и худшем случае.


### Пирамидальная сортировка (Heap Sort)
Пирамидальная сортировка — это алгоритм сортировки, который использует структуру

данных "куча" (heap). Идея заключается в том, что **массив представляется в виде двоичной кучи, а затем элементы извлекаются из кучи в порядке убывания**.

```go
func heapSort(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}
func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2
    if left < n && arr[left] > arr[largest] {
        largest = left
    }
    if right < n && arr[right] > arr[largest] {
        largest = right
    }
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}
```

**Эффективен при использовании на больших массивах.**

Сложность алгоритма: `O(n log n)` в среднем и худшем случае.

### Сортировка подсчетом (Counting Sort)
Сортировка подсчетом — это алгоритм сортировки, который использует дополнительный массив для подсчета количества вхождений каждого элемента. Идея заключается в том, что

**для каждого элемента массива подсчитывается количество его вхождений, а затем элементы выводятся в порядке возрастания на основе этих подсчетов**.

```go
func countingSort(arr []int) []int {
    if len(arr) == 0 {
        return arr
    }
    maxVal := arr[0]
    for _, val := range arr {
        if val > maxVal {   
            maxVal = val
        }
    }
    count := make([]int, maxVal+1)
    for _, val := range arr {
        count[val]++
    }
    result := make([]int, 0, len(arr))
    for i, c := range count {
        for j := 0; j < c; j++ {
            result = append(result, i)
        }
    }
    return result
}
```

**Эффективен при использовании на массивах с ограниченным диапазоном значений.**

Сложность алгоритма: `O(n + k)`, где `n` — количество элементов в массиве, а `k` — диапазон значений (максимальное значение элемента).

### Сортировка по радиксам (Radix Sort)
Сортировка по радиксам — это алгоритм сортировки, который использует метод "разделяй и властвуй" для сортировки чисел по разрядам. Идея заключается в том, что **числа сортируются по каждому разряду, начиная с младшего**.

```go
func countingSortForRadix(arr []int, exp int) {
    n := len(arr)
    output := make([]int, n)
    count := make([]int, 10)
    for i := 0; i < n; i++ {
        index := (arr[i] / exp) % 10
        count[index]++
    }
    for i := 1; i < 10; i++ {
        count[i] += count[i-1]
    }
    for i := n - 1; i >= 0; i-- {
        index := (arr[i] / exp) % 10
        output[count[index]-1] = arr[i]
        count[index]--
    }
    copy(arr, output)
}

func radixSort(arr []int) {
    maxVal := arr[0]
    for _, val := range arr {
        if val > maxVal {
            maxVal = val
        }
    }
    for exp := 1; maxVal/exp > 0; exp *= 10 {
        countingSortForRadix(arr, exp)
    }
}
```

**Эффективен при использовании на массивах с ограниченным диапазоном значений.**

Сложность алгоритма: `O(nk)`, где `n` — количество элементов в массиве, а `k` — количество разрядов в максимальном числе.

### Сортировка по корзинам (Bucket Sort)
Сортировка по корзинам — это алгоритм сортировки, который использует метод "

разделяй и властвуй" для сортировки чисел по корзинам. Идея заключается в том, что **числа распределяются по корзинам, а затем каждая корзина сортируется отдельно**.

```go
func bucketSort(arr []int) []int {
    if len(arr) == 0 {
        return arr
    }
    maxVal := arr[0]
    for _, val := range arr {
        if val > maxVal {       
            maxVal = val
        }
    }
    bucketCount := len(arr) / 2
    if bucketCount < 1 {
        bucketCount = 1
    }
    buckets := make([][]int, bucketCount)
    for _, val := range arr {
        index := val * bucketCount / (maxVal + 1)
        buckets[index] = append(buckets[index], val)
    }
    result := make([]int, 0, len(arr))
    for _, bucket := range buckets {
        if len(bucket) > 0 {
            insertionSort(bucket) // Используем сортировку вставками для сортировки каждой корзины
            result = append(result, bucket...)
        }
    }
    return result
}
```

**Эффективен при использовании на массивах с ограниченным диапазоном значений.**

Сложность алгоритма: `O(n + k)`, где `n` — количество элементов в массиве, а `k` — количество корзин.

### Сортировка по битам (Bitonic Sort)
Сортировка по битам — это алгоритм сортировки, который использует метод "разделяй и властвуй" для сортировки чисел по битам. Идея заключается в том, что **числа сортируются по битам, начиная с младшего**.

```go
func bitonicSort(arr []int, low, cnt int, dir int) {
    if cnt > 1 {
        k := cnt / 2
        if dir == 1 {
            for i := low; i < low+k; i++ {
                if arr[i] > arr[i+k] {
                    arr[i], arr[i+k] = arr[i+k], arr[i]
                }
            }
            bitonicSort(arr, low, k, dir)
            bitonicSort(arr, low+k, k, dir)
        } else {
            for i := low; i < low+k; i++ {
                if arr[i] < arr[i+k] {
                    arr[i], arr[i+k] = arr[i+k], arr[i]
                }
            }
            bitonicSort(arr, low, k, dir)
            bitonicSort(arr, low+k, k, dir)
        }
    }
}

func sort(arr []int, up bool) {
    dir := 0
    if up {
        dir = 1
    }
    bitonicSort(arr, 0, len(arr), dir)
}
```

**Эффективен при использовании на массивах с ограниченным диапазоном значений.**

Сложность алгоритма: `O(n log^2 n)` в среднем и худшем случае.