# Sliding Window

Паттерн "скользящее окно".  
Является продолжением идеи Two Pointers.

Расстояние между указателями фиксируется и задано в задаче.  
i=0: [x<sub>↑</sub>, x, x, x, x<sub>↑</sub>, x, x, x]  
i=1: [x, x<sub>↑</sub>, x, x, x, x<sub>↑</sub>, x, x]  
i=2: [x, x, x<sub>↑</sub>, x, x, x, x<sub>↑</sub>, x]  
i=3: [x, x, x, x<sub>↑</sub>, x, x, x, x<sub>↑</sub>]  
расстояние: 4  

1. Берём указатель на начало `begin = 0`.  
2. Запускаем цикл по указателю на конец окна `end = 0...n-1`.
3. Храним состояние окна.
4. Подтягиваем `begin`, если он выпадает из окна.  
   При этом, при изменении окна, необходимо оптимально изменять его состояние:  
   исключить выпавший элемент и включить новый.

Каркас: 
```go
begin = 0  
window_state  

for end := 0; end < len(nums)-1; end++ {  
    window_size := end - begin + 1  
    if # window_condition {  
        begin++  
    }  
}  
```

### 643. Maximum Average Subarray I

**Алгоритм:**
1. Проверяем, если `k == 0`, возвращаем `NaN` (ошибка).
2. Инициализируем переменные: `begin = 0`, `windowSum = 0`, `maxSum = math.MinInt32`.
3. Перебираем массив с индексом `end`:
   - Добавляем `nums[end]` к сумме окна.
   - Когда размер окна достигает `k`, обновляем максимальную сумму и сдвигаем окно, вычитая `nums[begin]` и увеличивая `begin`.
4. Возвращаем максимальную сумму, разделённую на `k` для получения среднего значения.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`
### 209. Minimum Size Subarray Sum

**Алгоритм:**
1. Инициализируем переменные: `begin = 0`, `windowSum = 0`, `minWindowSize = len(nums) + 1`.
2. Перебираем массив с индексом `end`:
   - Добавляем `nums[end]` к сумме окна.
   - Если сумма окна больше или равна `target`, сдвигаем `begin`, уменьшая сумму, и обновляем минимальный размер окна.
3. Если минимальный размер окна не был обновлён, возвращаем 0 (не существует подходящего окна).
4. Возвращаем минимальный размер окна.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

### 1004. Max Consecutive Ones III

**Алгоритм:**  
1. Инициализируем переменные: `windowCountZero = 0`, `maxWindowSize = 0`, `begin = 0`.  
2. Перебираем массив с индексом `end`:  
   - Если `nums[end] == 0`, увеличиваем `windowCountZero`.
   - Если `windowCountZero > k`, сдвигаем `begin`, уменьшая `windowCountZero`, пока не станет `<= k`.  
3. Обновляем максимальный размер окна: `maxWindowSize = max(maxWindowSize, end - begin + 1)`.  
4. Возвращаем `maxWindowSize`.  

**Сложность:**  
- Время: `O(n)`  
- Память: `O(1)`  

#### Сложность  
**Time**: O(n)  
**Space**: O(1) 


### 1493. Longest Subarray of 1's After Deleting One Element

**Алгоритм:**
1. Инициализируем переменные: `maxWindowSize = 0`, `windowCountZero = 0`, `begin = 0`.
2. Перебираем массив с индексом `end`:
   - Если `nums[end] == 0`, увеличиваем `windowCountZero`.
   - Если количество нулей в окне больше 1, сдвигаем `begin`, уменьшая `windowCountZero`, пока его количество не станет ≤ 1.
3. Обновляем максимальный размер окна: `maxWindowSize = max(maxWindowSize, end - begin)`.
4. Возвращаем максимальный размер окна.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)`

### 904. Fruit Into Baskets  
**Алгоритм:**
1. Инициализируем `fruitMap` для хранения количества фруктов в текущем окне, `maxWindowSize = 0`, `begin = 0`.
2. Перебираем массив с индексом `end`:
   - Увеличиваем счётчик `fruitMap[fruits[end]]`.
   - Если в `fruitMap` больше 2 разных фруктов, сдвигаем `begin`, уменьшая количество фруктов в окне.
   - Если количество какого-либо фрукта стало 0, удаляем его из `fruitMap`.
3. Обновляем максимальный размер окна: `maxWindowSize = max(maxWindowSize, end - begin + 1)`.
4. Возвращаем `maxWindowSize`.

**Сложность:**
- Время: `O(n)`
- Память: `O(1)` (максимум 3 различных ключа в `fruitMap`)
